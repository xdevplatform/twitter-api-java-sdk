/*
Copyright 2020 Twitter, Inc.
SPDX-License-Identifier: Apache-2.0

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
https://openapi-generator.tech
Do not edit the class manually.
*/


package com.twitter.clientlib;


import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.InterruptedIOException;
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

public class TweetsStreamListenersExecutor {
  private final static int TIMEOUT_MILLIS = 60000;
  private final static int SLEEP_MILLIS = 100;
  private final static int BACKOFF_SLEEP_INTERVAL_MILLIS = 5000;
  private TweetsQueuer tweetsQueuer;
  private ITweetsQueue tweetsQueue = new LinkedListTweetsQueue();
  private final AtomicBoolean isRunning = new AtomicBoolean(true);
  private final AtomicLong tweetStreamedTime = new AtomicLong(0);
  private Exception caughtException;
  private IStreamingHandler<?> streamingHandler;
  private long reconnecting = 0;

  public StreamListenersExecutorBuilder stream() {
    return new StreamListenersExecutorBuilder();
  }

  private void shutdown(Exception e) {
    caughtException = e;
    e.printStackTrace();
    shutdown();
  }

  public void shutdown() {
    isRunning.set(false);
    System.out.println("TweetsStreamListenersExecutor is shutting down.");
  }

  public Exception getError() {
    return caughtException;
  }

  private InputStream connectStream() throws ApiException {
    return streamingHandler.connectStream();
  }

  private void resetTweetStreamedTime() {
    tweetStreamedTime.set(System.currentTimeMillis());
  }

  private boolean isTweetStreamedError() {
    return System.currentTimeMillis() - tweetStreamedTime.get() > TIMEOUT_MILLIS;
  }

  private void restartTweetsQueuer() {
    tweetsQueuer.shutdownQueuer();
    if(reconnecting < 7) {
      reconnecting++;
    }
    try {
      System.out.println("sleeping " + BACKOFF_SLEEP_INTERVAL_MILLIS * reconnecting);
      Thread.sleep(BACKOFF_SLEEP_INTERVAL_MILLIS * reconnecting); // Wait a bit before starting the TweetsQueuer and calling the API again.
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    tweetsQueuer.interrupt();
    tweetsQueuer = new TweetsQueuer();
    tweetsQueuer.start();
  }

  private class TweetsListenersExecutor extends Thread {
    @Override
    public void run() {
      processTweets();
    }

    private void processTweets() {
      String tweetString;
      try {
        while (isRunning.get()) {
          tweetString = tweetsQueue.poll();
          if (tweetString == null) {
            Thread.sleep(SLEEP_MILLIS);
            continue;
          }
          try {
            if(!streamingHandler.processAndVerifyStreamingObject(tweetString)) {
              restartTweetsQueuer();
            }
          } catch (Exception interExcep) {
            interExcep.printStackTrace();
          }
        }
      } catch (Exception e) {
        shutdown(e);
      }
    }
  }

  private class TweetsQueuer extends Thread {
    private boolean isReconnecting;
    @Override
    public void run() {
      isReconnecting = false;
      queueTweets();
    }

    public void shutdownQueuer() {
      isReconnecting = true;
    }
    private void queueTweets() {
      String line;
      try (BufferedReader reader = new BufferedReader(new InputStreamReader(connectStream()))) {
        while (isRunning.get() && !isReconnecting) {
          line = reader.readLine();
          resetTweetStreamedTime();
          if (line == null || line.isEmpty()) {
            Thread.sleep(SLEEP_MILLIS);
            continue;
          }
          tweetsQueue.add(line);
        }
      } catch (InterruptedIOException e) {
        e.printStackTrace();
      } catch (Exception e) {
        shutdown(e);
      }
    }
  }

  private class StreamTimeoutChecker extends Thread {
    @Override
    public void run() {
      checkTimes();
    }

    public void checkTimes()  {
      resetTweetStreamedTime();
      while (isRunning.get()) {
        if(isTweetStreamedError()) {
          shutdown(new ApiException("Tweets are not streaming"));
        }
        try {
          Thread.sleep(SLEEP_MILLIS);
        } catch (InterruptedException interExcep) {
          interExcep.printStackTrace();
        }
      }
    }
  }

  public class StreamListenersExecutorBuilder {
    public StreamListenersExecutorBuilder streamingHandler(IStreamingHandler<?> streamHandler) {
      streamingHandler = streamHandler;
      return this;
    }

    public StreamListenersExecutorBuilder tweetsQueue(ITweetsQueue queue) {
      tweetsQueue = queue;
      return this;
    }

    public void executeListeners() throws ApiException {
      if (streamingHandler == null) {
        throw new ApiException("Please set a streamingHandler");
      } else if (tweetsQueue == null) {
        System.out.println("Error: tweetsQueue is null.");
        return;
      }

      TweetsListenersExecutor tweetsListenersExecutor;
      StreamTimeoutChecker timeoutChecker;
      tweetsQueuer = new TweetsQueuer();
      tweetsListenersExecutor = new TweetsListenersExecutor();
      timeoutChecker = new StreamTimeoutChecker();
      tweetsListenersExecutor.start();
      tweetsQueuer.start();
      timeoutChecker.start();
    }
  }
}

interface ITweetsQueue {
  String poll();
  void add(String streamingTweet);
}

class LinkedListTweetsQueue implements ITweetsQueue {
  private final Queue<String> tweetsQueue = new LinkedList<>();

  @Override
  public String poll() {
    return tweetsQueue.poll();
  }

  @Override
  public void add(String streamingTweet) {
    tweetsQueue.add(streamingTweet);
  }
}
